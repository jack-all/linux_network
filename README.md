# 1.硬件和驱动处理流程

## 1.1 接收报文流程：

（1）当接到一个报文后，首先会去掉报文前导码和帧起始字段。

（2）网卡会根据接口配置的过滤条件过滤报文，符合过滤条件的的报文且CRC校验正确的报文会触发中断给CPU。

（3）linux网卡驱动程序在报文接受硬中断后，中断处理中会创建skb对象，并触发DMA，将硬件网卡中的数据复制skb中（CPU的内存中），之后调用linux的netif_rx函数。

（4）linux netif_rx函数将该端口设备加入到该cpu的输入队列的设备列表中，如果是该cpu接受的第一个报文，则会触发接受软中断，然后将报放入到该cpu的接受报文队列中（报文真正处理在软中断中进行，避免cpu一致卡在中断中，导致cpu其它任务无法处理）。

（5）报文接受软中断函数是在net_dev初始化时初始化为net_rx_action,软中断net_rx_action会遍历该cpu的待处理的设备列表，然后调用设备的poll函数。

（6）net_dev的poll初始化为process_backlog，process_backlog会调用netif_receive_skb进入协议栈主处理函数中。

_注：1-2是硬件处理流程，3是驱动代码处理，4-是linux内核代码处理_

## 1.2 发送报文流程：

（1）驱动调用net_dev的hard_start_xmit方法发送报文。

（2）驱动函数会下配DMA配置，将cpu中的数据内容通过DMA方式copy到网卡中。

（3）但DMA复制完成后，会触发中断，通知给驱动程序。

（4）驱动会配置网卡发送寄存器，并将该skb放入到cpu的完成队列中，然后触发软中断（NET_TX_SOFTIRQ），软中断在net_dev初始化阶段初始化为net_tx_action。

（5）软中断net_tx_action会遍历该cpu的完成队列，并将该队列中的skb内存都释放掉。

# 2.数据链路层处理流程

# 3.网络层处理流程
